import { Job } from './job/job-class';
import type { JobId, JobType, JobDocument, JobLogEntry, JobLogLevel, JobStatus, LaterJSSchedule, GetWorkOptions, GetJobOptions, ReadyJobsOptions } from './types';
import { validNumGTEZero, validNumGTZero, validNumGTEOne, validIntGTEZero, validIntGTEOne, validStatus, validLogLevel, validRetryBackoff, validId as isValidId } from './utils/validators';
declare function validLog(): any;
declare function validProgress(): any;
declare function validJobDoc(): any;
export declare class JobCollectionBase extends Mongo.Collection<JobDocument> {
    root: string;
    later: any;
    _validNumGTEZero: typeof validNumGTEZero;
    _validNumGTZero: typeof validNumGTZero;
    _validNumGTEOne: typeof validNumGTEOne;
    _validIntGTEZero: typeof validIntGTEZero;
    _validIntGTEOne: typeof validIntGTEOne;
    _validStatus: typeof validStatus;
    _validLogLevel: typeof validLogLevel;
    _validRetryBackoff: typeof validRetryBackoff;
    _validId: typeof isValidId;
    _validLog: typeof validLog;
    _validProgress: typeof validProgress;
    _validJobDoc: typeof validJobDoc;
    jobLogLevels: readonly ["info", "success", "warning", "danger"];
    jobPriorities: {
        readonly low: 10;
        readonly normal: 0;
        readonly medium: -5;
        readonly high: -10;
        readonly critical: -15;
    };
    jobStatuses: readonly ["waiting", "paused", "ready", "running", "failed", "cancelled", "completed"];
    jobStatusCancellable: readonly ["running", "ready", "waiting", "paused"];
    jobStatusPausable: readonly ["ready", "waiting"];
    jobStatusRemovable: readonly ["cancelled", "completed", "failed"];
    jobStatusRestartable: readonly ["cancelled", "failed"];
    forever: number;
    foreverDate: Date;
    ddpMethods: readonly ["startJobs", "stopJobs", "startJobServer", "shutdownJobServer", "jobRemove", "jobPause", "jobResume", "jobReady", "jobCancel", "jobRestart", "jobSave", "jobRerun", "getWork", "getJob", "jobLog", "jobProgress", "jobDone", "jobFail"];
    ddpPermissionLevels: readonly ["admin", "manager", "creator", "worker"];
    ddpMethodPermissions: {
        readonly startJobs: readonly ["startJobs", "admin"];
        readonly stopJobs: readonly ["stopJobs", "admin"];
        readonly startJobServer: readonly ["startJobServer", "admin"];
        readonly shutdownJobServer: readonly ["shutdownJobServer", "admin"];
        readonly jobRemove: readonly ["jobRemove", "admin", "manager"];
        readonly jobPause: readonly ["jobPause", "admin", "manager"];
        readonly jobResume: readonly ["jobResume", "admin", "manager"];
        readonly jobCancel: readonly ["jobCancel", "admin", "manager"];
        readonly jobReady: readonly ["jobReady", "admin", "manager"];
        readonly jobRestart: readonly ["jobRestart", "admin", "manager"];
        readonly jobSave: readonly ["jobSave", "admin", "creator"];
        readonly jobRerun: readonly ["jobRerun", "admin", "creator"];
        readonly getWork: readonly ["getWork", "admin", "worker"];
        readonly getJob: readonly ["getJob", "admin", "worker"];
        readonly jobLog: readonly ["jobLog", "admin", "worker"];
        readonly jobProgress: readonly ["jobProgress", "admin", "worker"];
        readonly jobDone: readonly ["jobDone", "admin", "worker"];
        readonly jobFail: readonly ["jobFail", "admin", "worker"];
    };
    jobDocPattern: any;
    _createLogEntry: (message: string, runId?: JobId | null, level?: JobLogLevel, time?: Date, data?: any) => JobLogEntry;
    _logMessage: Record<string, (...args: any[]) => JobLogEntry>;
    _toLog?: (userId: string, method: string, message: string) => void;
    _unblockDDPMethods?: boolean;
    scrubJobDoc?: (job: JobDocument) => JobDocument;
    constructor(root?: string, options?: any);
    processJobs(type: any, options: any, worker?: any): import(".").JobQueue;
    getJob(id: JobId, options?: any, cb?: any): Promise<Job | undefined>;
    getWork(type: any, options?: any, cb?: any): Promise<Job | Job[]>;
    getJobs(ids: JobId[], options?: any, cb?: any): Promise<Job[]>;
    readyJobs(ids?: JobId[], options?: any, cb?: any): Promise<boolean>;
    cancelJobs(ids: JobId[], options?: any, cb?: any): Promise<boolean>;
    pauseJobs(ids: JobId[], options?: any, cb?: any): Promise<boolean>;
    resumeJobs(ids: JobId[], options?: any, cb?: any): Promise<boolean>;
    restartJobs(ids: JobId[], options?: any, cb?: any): Promise<boolean>;
    removeJobs(ids: JobId[], options?: any, cb?: any): Promise<boolean>;
    setDDP(ddp?: any, names?: any): void;
    startJobServer(options?: any, cb?: any): Promise<boolean>;
    shutdownJobServer(options?: any, cb?: any): Promise<boolean>;
    startJobs(options?: any, cb?: any): Promise<boolean>;
    stopJobs(options?: any, cb?: any): Promise<boolean>;
    setJobPermissions(type: 'allow' | 'deny', _options: any): void;
    promote(_milliseconds?: number): void;
    setLogStream(_writeStream?: any): void;
    logConsole?: boolean;
    makeJob(type: any, data?: any): Job;
    createJob(type: any, data?: any): Job;
    _methodWrapper(method: string, func: Function): Function;
    _generateMethods(): Record<string, Function>;
    _idsOfDeps(ids: JobId[], antecedents: boolean, dependents: boolean, jobStatuses: readonly JobStatus[] | JobStatus[]): Promise<JobId[]>;
    _rerun_job(doc: JobDocument, repeats?: number, wait?: number | LaterJSSchedule, repeatUntil?: Date): Promise<JobId | null>;
    _checkDeps(job: JobDocument, dryRun?: boolean): Promise<any>;
    _DDPMethod_startJobServer(options?: any): Promise<boolean>;
    _DDPMethod_startJobs(options?: any): Promise<boolean>;
    _DDPMethod_shutdownJobServer(options?: any): Promise<boolean>;
    _DDPMethod_stopJobs(options?: any): Promise<boolean>;
    _DDPMethod_getJob(ids: JobId | JobId[], options?: GetJobOptions): Promise<JobDocument | JobDocument[] | null>;
    _DDPMethod_getWork(type: JobType | JobType[], options?: GetWorkOptions): Promise<JobDocument[]>;
    _DDPMethod_jobRemove(ids: JobId | JobId[], options?: any): Promise<boolean>;
    _DDPMethod_jobPause(ids: JobId | JobId[], options?: any): Promise<boolean>;
    _DDPMethod_jobResume(ids: JobId | JobId[], options?: any): Promise<boolean>;
    _DDPMethod_jobReady(ids?: JobId | JobId[], options?: ReadyJobsOptions): Promise<boolean>;
    _DDPMethod_jobCancel(ids: JobId | JobId[], options?: any): Promise<boolean>;
    _DDPMethod_jobRestart(ids: JobId | JobId[], options?: any): Promise<boolean>;
    _DDPMethod_jobSave(doc: JobDocument, options?: any): Promise<JobId | false | null>;
    _DDPMethod_jobProgress(id: JobId, runId: JobId, completed: number, total: number, options?: any): Promise<boolean | null>;
    _DDPMethod_jobLog(id: JobId, runId: JobId | null, message: string, options?: any): Promise<boolean>;
    _DDPMethod_jobRerun(id: JobId, options?: any): Promise<JobId | false>;
    _DDPMethod_jobDone(id: JobId, runId: JobId, result: any, options?: any): Promise<boolean | JobId>;
    _DDPMethod_jobFail(id: JobId, runId: JobId, err: any, options?: any): Promise<boolean>;
}
export { JobCollectionBase as JobCollection };
//# sourceMappingURL=shared.d.ts.map